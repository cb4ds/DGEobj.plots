#' Function obsPlot
#'
#' Provides a summary plot (box/violin/points) for each observation (gene), showing data for each
#' experiment group. The plot can optionally include either one or both of the boxplot and violinplot layer
#' can additionally choose to display points and/or mean of all the points on the plot.  The boxLayer and the
#' violin layer can be customized to have the desired transparency, colors etc. By default, the violinLayer is
#' not displayed and only the boxplot, points and the mean on the plots can be seen.
#'
#' Also, by default, the plots are faceted.  Faceting the plot can be turned off to return a list of individual
#' plots for each gene.
#'
#' Input is a dataframe or matrix of intensity values with geneID row names and sample name column names,
#' e.g. from log2cpm. Group must also be specified as the plots are grouped by this attribute.
#'
#' @param data A  DGEObject. The countsMatrix in the DGEObject is extracted to plot the data. (required)
#' @param plotType Can be canvasXpress or ggplot (default = canvasXpress)
#' @param designTable Name of the design table in the DGEObj from which the grouping column will be extracted. (default = design)
#' @param group Define the column name to group boxplots by (typically a replicate group column) (required)
#' @param boxLayer Adds a boxplot layer (default = TRUE)
#' @param violinLayer Adds a violin layer (default = FALSE)
#' @param showPoints Shows the datapoints on the plot only if boxLayer or violinLayer is enabled. (default = TRUE)
#' @param showMean Show the mean of the points on the plot only if boxLayer is enabled. (default = TRUE)
#' @param xlab X axis label (defaults to group column name if not specified)
#' @param ylab Y axis label (defaults to value column name if not specified)
#' @param title Plot title (optional)
#' @param boxColor Color for the boxplot layer (default = "deepskyblue3")
#' @param boxTransparency Transparency for the box layer (default = 0.5)
#' @param violinColor Color for the violin layer (default = "yellow")
#' @param violinTransparency Transparency for the violin layer (default = 0.5)
#' @param facet Specifies whether to facet (TRUE) or print individual plots
#'   (FALSE)  (default = TRUE)
#' @param facetRow Explicitly set the number of rows for the facet plot.
#'   Default behavior will automatically set the columns.
#' @param labelAngle Angle to set the sample labels on the X axis. (default =  30; range = 0-90)
#' @param axisFree Specify same scale or independent scales for each subplot (default = TRUE;
#'   Allowed values: TRUE and FALSE)
#'
#' @return Plot of type canvasXpress or ggplot. If Facet = TRUE (default) returns a faceted object. If
#'   facet = FALSE, returns a list of objects indexed
#'   by observation (gene) names.
#'
#' @examples
#' \dontrun{
#'
#'   # Faceted boxplot
#'   obsPlot(DGEobj,
#'           designTable = "design",
#'           group = "replicategroup")
#'
#'   # Faceted violin plot
#'   obsPlot(DGEobj,
#'            violinLayer = TRUE,
#'            boxLayer = FALSE,
#'            designTable = "design",
#'            group = "replicategroup")
#'
#'   # Return a list of plot for each individual gene
#'   myplots <- obsPlot(DGEobj,
#'                      designTable = "design",
#'                      group = "replicategroup"
#'                      facet = FALSE)
#'   # Plot one from the list
#'   myplots[[2]]
#' }
#'
#' @import ggplot2 magrittr
#' @importFrom tidyr gather
#' @importFrom dplyr left_join filter select
#' @importFrom assertthat assert_that
#' @importFrom canvasXpress canvasXpress
#'
#' @export
obsPlot <- function(DGEdata,
                    plotType    = "canvasXpress",
                    countsMatrix = "counts",
                    convertCounts = NULL,
                    convert_geneLength,
                    convert_log = FALSE,
                    convert_normalize = "none",
                    convert_prior.count = NULL,
                    designTable = "design",
                    group       = "replicategroup",
                    violinLayer  = FALSE,
                    showPoints  = TRUE,
                    xlab,
                    ylab,
                    title,
                    boxColor    = "deepskyblue3",
                    facet       = TRUE,
                    facetRow,
                    axisFree    = TRUE) {
    assertthat::assert_that(!missing(DGEdata),
                            !is.null(DGEdata),
                            "DGEobj" %in% class(DGEdata),
                            msg = "DGEdata must be specified and should be of class DGEobj")
    assertthat::assert_that(!is.null(getType(DGEdata,"counts")),
                            msg = "counts matrix must be available in DGEdata to plot the data.")
    assertthat::assert_that(!is.null(getType(DGEdata,"design")),
                            msg = "design table must be available in DGEdata to plot the data.")

    #convertCounts value validation


    #countsMatrix
    if (any(is.null(countsMatrix),
            !is.character(countsMatrix),
            !(countsMatrix %in% names(DGEdata)))) {
        if ("counts" %in% names(DGEdata)) {
            countsMatrix <- "counts"
            warning("countsMatrix specified is not present in DGEobj. Assigning default value of 'counts'.")
        } else if (!is.null(getType(DGEdata,"counts"))) {
            countsMatrix <- names(getType(DGEdata,"counts"))
        }
    }

    #convertCounts
    if (!is.null(convertCounts) &&
        any(!is.character(convertCounts),
            length(convertCounts != 1),
            !(toupper(convertCounts) %in% c("CPM", "FDPKM", "FPK", "TPM")))) {
        warning("Invalid value specificed for convertCounts. It must be null if counts matrix need not be converted or must be one of CPM, FPKM, FPK, and TPM. Assigning default value 'NULL'")
        convertCounts <- NULL
    }

    if (!is.null(convertCounts)) {
        if (any(length(convert_log) != 1,
                is.null(convert_log),
                !is.logical(convert_log))) {
            warning("Invalid value specified for convert_log. Assigning default value FALSE.")
            convert_log <- FALSE
        }

        if (any(length(convert_normalize) != 1,
                is.null(convert_normalize),
                !is.character(convert_normalize),
                !(toupper(convert_normalize) %in% c("TMM", "RLE", "UPPERQUARTILE", "TMMWZP")))) {
            warning("Invalid value specified for convert_normalize. Must be one of 'TMM', 'RLE', 'upperquartile', 'TMMwzp' or 'none'. Assigning default value 'none'.")
            convert_normalize <- "none"
        }

        if (!missing(convert_geneLength)) {
            assertthat::assert_that(length(convert_geneLength) == nrow(getItem(DGEdata, countsMatrix)),
                                    msg = "geneLength must be the same length of the number of rows in countsMatrix.")
        }

        if (any(length(convert_prior.count) != 1,
                !is.numeric(convert_prior.count))) {
            warning("Invalid value specified for convert_prior.count Assigning default value NULL.")
            convert_prior.count <- NULL
        }

        data <- convertCounts(getItem(DGEdata, countsMatrix),
                                      unit = convertCounts,
                                      geneLength = convert_geneLength,
                                      log = convert_log,
                                      normalize = convert_normalize,
                                      prior.count = convert_prior.count) %>%
            as.data.frame()
    } else {
        data <- getItem(DGEdata, countsMatrix) %>%
            as.data.frame()
    }

        if (any(is.null(designTable),
                !is.character(designTable),
                !(designTable %in% names(DGEdata)))) {
            if ("design" %in% names(DGEdata)) {
                designTable <- "design"
                warning("designTable specified is not present in DGEobj. Assigning default value of type 'design'.")
            } else if (!is.null(getType(DGEdata,"design"))) {
                designTable <- names(getType(DGEdata,"design"))
            }
        }

    design            <- DGEobj::getItem(DGEdata, designTable)
    colnames(design)  <- tolower(colnames(design))
    group_default     <- NULL
    if (tolower("ReplicateGroup") %in% colnames(design)) {
        group_default <- "replicategroup"
    }

    if (any(is.null(group),
            !(tolower(group) %in% colnames(design)))) {
        if (!is.null(group_default)) {
            warning("group must be specified and should be one of the columns in the design object in DGEdata. Assigning ",
                    group_default,
                    " as the default value.")
            group <- group_default
        } else {
            stop("group must be specified and should be one of the columns in the designTable in DGEdata.")
        }
    }

    # Create a rownames column
    data$GeneID    <- rownames(data)
    rownames(data) <- NULL
    data           <- tidyr::gather(data, key = "sample", value = "value",-GeneID)

    group      <- tolower(group)
    group.data <- design %>% dplyr::select(!!group)
    colnames(group.data) <- "group"
    group.data$sample    <- rownames(group.data);rownames(group.data) <- NULL
    data <- dplyr::left_join(data, group.data, by = "sample" )
    data <- data %>% filter(GeneID %in% unique(data$GeneID)[1:6])

    plotByCol <- "GeneID"
    valueCol  <- "value"
    groupCol  <- "group"

    #input validations
    plotType <- tolower(plotType)
    facet_chart_limit <- 40

    if (any(is.null(facet),
            !is.logical(facet),
            length(facet) != 1)) {
        warning("facet must be a singular logical value. Assigning default value TRUE.")
        facet <- TRUE
    }

    if (facet) {
        #Number of charts to plot
        if (nrow(unique(data[plotByCol])) > facet_chart_limit) {
            warning(paste("A large number of charts/facets has/have been requested and may take significant time to generate.  It is suggested that less than",
                          facet_chart_limit,
                          "charts/facets are requested at a time"))
        }

        #facetRow
        numrow <- data[plotByCol] %>%
            unique %>%
            length %>%
            sqrt %>%
            ceiling
    }

    if (missing(title)) {
        title <- NULL
    } else if ((!is.null(title)) &&
               (!is.character(title) || length(title) != 1)) {
        warning("Invalid title specificed. Title must be singular value of class character.")
        title <- NULL
    }

    if ((!missing(xlab)) &&
        (!is.null(xlab)) &&
        ((!is.character(xlab)) || length(xlab) != 1)) {
        warning("xlab value specified is not valid. Assigning groupCol name as the default value.")
        xlab <- groupCol
    } else if (missing(xlab)) {
        xlab <- groupCol
    }

    if (!missing(ylab) &&
        !is.null(ylab) &&
        (!is.character(ylab) || length(ylab) != 1)) {
        warning("ylab value specified is not valid. Assigning valueCol name as the default value.")
        ylab <- valueCol
    } else if (missing(ylab)) {
        ylab <- valueCol
    }


    labelAngle <- 30

    if (any(is.null(violinLayer),
            length(violinLayer) != 1,
            !is.logical(violinLayer))) {
        warning("violinLayer must be a singular logical value. Assigning default value FALSE.")
        violinLayer <- FALSE
    }

    #color Validations
    if (any(is.null(boxColor),
            length(boxColor) != 1,
            !is.character(boxColor))) {
        warning("boxColor must be of class character and must specify the name of the color or the rgb value. Assigning default value 'deepskyblue3'.")
        boxColor <- "deepskyblue3"
    } else if (.rgbaConversion(boxColor) == "invalid value") {
        warning("boxColor specified is not valid. Assigning default value 'deepskyblue3'.")
        boxColor <- "deepskyblue3"
    }


    # ViolinLayer Validations
    if (violinLayer) {
        # if (any(is.null(violinColor),
        #         length(violinColor) != 1,
        #         !is.character(violinColor))) {
        #     warning("violinColor must be of class character and must specify the name of the color or the rgb value. Assigning default value 'goldenrod1'.")
        #     violinColor <- "goldenrod1"
        # } else if (.rgbaConversion(violinColor) == "invalid value") {
        #     warning("violinColor specified is not valid. Assigning default value 'goldenrod1'.")
        #     violinColor <- "goldenrod1"
        # }
    }

    showMean <- TRUE

    #point validations
    if (any(is.null(showPoints),
            length(showPoints) != 1,
            !is.logical(showPoints))) {
        warning("showPoints must be a singular logical value. Assigning default value TRUE.")
        showPoints <- TRUE
    }

    #axisFree
    if (any(is.null(axisFree),
            length(axisFree) != 1,
            !is.logical(axisFree))) {
        warning("axisFree must be a singular logical value. Assigning default value TRUE.")
        axisFree <- TRUE
    }

    obsPlot <- NULL
    if (plotType == "canvasxpress") {
        if (facet) {
            numcol   <- ((data[[plotByCol]] %>% unique %>% length) / numrow) %>% ceiling
            cx_data  <- data %>% select(!!rlang::sym(valueCol)) %>% t() %>% as.data.frame()
            smp_data <- data %>% select(-!!rlang::sym(valueCol))
            rownames(smp_data) <- colnames(cx_data)
            obsPlot  <- canvasXpress(data               = cx_data,
                                    smpAnnot            = smp_data,
                                    graphOrientation    = "vertical",
                                    graphType           = "Boxplot",
                                    groupingFactors     = groupCol,
                                    boxplotColor        = boxColor,
                                    boxplotMean         = showMean,
                                    boxplotWhiskersType = "single",
                                    showViolinBoxplot   = violinLayer,
                                    showBoxplotIfViolin = TRUE,
                                    violinColor         = boxColor,
                                    smpLabelRotate      = 30,
                                    smpLabelScaleFontFactor = 1,
                                    smpTitle            = xlab,
                                    smpTitleFontStyle   = "bold",
                                    smpTitleScaleFontFactor = 1,
                                    layoutAdjust        = axisFree,
                                    showBoxplotOriginalData = showPoints,
                                    theme               = "CanvasXpress",
                                    xAxisTitle          = ylab,
                                    xAxis2Show          = TRUE,
                                    title               = title,
                                    showLegend          = FALSE,
                                    layoutTopology      = paste0(numrow, "X", numcol),
                                    segregateSamplesBy  = plotByCol)
        } else {
            plotlist   <- list()
            plotby_vec <- unique(data[[plotByCol]])
            obsPlot    <- lapply(plotby_vec, function(x) {
                data_subset <- data %>%
                    filter(!!rlang::sym(plotByCol) == x)
                cx_data <- data_subset %>%
                    select(!!rlang::sym(valueCol)) %>%
                    t() %>%
                    as.data.frame()
                smp_data <- data_subset %>%
                    select(-!!rlang::sym(valueCol))
                rownames(smp_data) <- colnames(cx_data)
                title <- x

                canvasXpress(data                = cx_data,
                             smpAnnot            = smp_data,
                             graphOrientation    = "vertical",
                             graphType           = "Boxplot",
                             groupingFactors     = groupCol,
                             boxplotColor        = boxColor,
                             boxplotMean         = showMean,
                             boxplotWhiskersType = "single",
                             showViolinBoxplot   = violinLayer,
                             showBoxplotIfViolin = TRUE,
                             violinColor         = boxColor,
                             smpLabelRotate      = 30,
                             smpLabelScaleFontFactor = 1,
                             smpTitle            = xlab,
                             smpTitleFontStyle   = "bold",
                             smpTitleScaleFontFactor = 1,
                             layoutAdjust        = axisFree,
                             showBoxplotOriginalData = showPoints,
                             theme               = "CanvasXpress",
                             xAxisTitle          = ylab,
                             title               = title,
                             xAxis2Show          = TRUE,
                             showLegend          = FALSE)
            })
        }
    } else {
        .addGeoms <- function(obsPlot) {
            obsPlot <- obsPlot + geom_boxplot(
                alpha = boxTransparency,
                color = boxColor,
                fill  = boxColor,
                outlier.shape = outlier.shape,
                outlier.size  = outlier.size
            ) +
            stat_summary(fun   = mean,
                        geom  = "point",
                        shape = "square",
                        size  = 3,
                        color = "goldenrod1",
                        fill  = "red2",
                        alpha = 0.7)

            if (violinLayer) {
                obsPlot <- obsPlot + geom_violin(alpha = violinTransparency,
                                                 color = violinColor,
                                                 fill  = violinColor)
            }

            if (showPoints) {
                    obsPlot <-
                        obsPlot + geom_point(position = position_jitter(width = 0.1),
                                             alpha    = 0.5,
                                             color    = "grey30",
                                             fill     = "dodgerblue4",
                                             size     = 2,
                                             shape    = "circle")
            }

            if (showMean) {
                obsPlot <- obsPlot + stat_summary(fun   = mean,
                                                  geom  = "point",
                                                  shape = "square",
                                                  size  = 3,
                                                  color = "goldenrod1",
                                                  fill  = "red2",
                                                  alpha = 0.7)
            }

            obsPlot
        }

        # Reduce box outliers to a dot if geom_points turned on
        outlier.size  <- 1.5
        outlier.shape <- 19
        if (showPoints) {
            outlier.size  <- 1
            outlier.shape <- "."
        }

        if (axisFree) {
            axisFree <- "free"
        } else {
            axisFree <- "fixed"
        }

        # Plot code here
        if (facet) {
            obsPlot <- ggplot2::ggplot(data, aes_string(x = groupCol, y = valueCol))
            obsPlot <- .addGeoms(obsPlot)
            facetFormula <- stringr::str_c("~", plotByCol, sep = " ")
            obsPlot <- obsPlot + ggplot2::facet_wrap(facetFormula, nrow = numrow, scales = axisFree)
            obsPlot <- obsPlot + ggplot2::xlab(xlab)
            obsPlot <- obsPlot + ggplot2::ylab(ylab)
            if (!missing(title)) {
                obsPlot <- obsPlot + ggplot2::ggtitle(title)
            }

            # Rotate xaxis group labels
            if (labelAngle > 0) {
                obsPlot <- obsPlot + theme(axis.text.x = element_text(angle = 30, hjust = 1))
            }
        } else {
            plotlist <- list()
            for (obs in unique(data[[plotByCol]])) {
                dat   <- data[data[[plotByCol]] == obs, ]
                aplot <- ggplot(dat, aes_string(x = groupCol, y = valueCol)) +
                    xlab(xlab) +
                    ylab(ylab) +
                    ggtitle(obs)
                aplot <- .addGeoms(aplot)

                # Rotate xaxis group labels
                if (labelAngle > 0) {
                    aplot <- aplot + theme(axis.text.x = element_text(angle = labelAngle, hjust = 1))
                }
                plotlist[[obs]] <- aplot
            }
            obsPlot <- plotlist
        }
    }
    return(obsPlot)
}
